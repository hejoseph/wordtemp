<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Remplisseur de formulaires DOCX — MVP monofichier</title>
<style>
  :root{--bg:#f6f8fb;--card:#fff;--accent:#2b6cb0;--muted:#666}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; margin:0;background:var(--bg);color:#111}
  .wrap{max-width:1000px;margin:28px auto;padding:20px}
  .card{background:var(--card);border-radius:10px;box-shadow:0 6px 18px rgba(20,30,40,0.06);padding:18px}
  .card-header img{margin:2em}
  h1{margin:0 0 8px;font-size:20px}
  p.lead{margin:0 0 14px;color:var(--muted)}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  input[type=file]{display:block}
  button{background:var(--accent);color:white;border:0;padding:8px 12px;border-radius:8px;cursor:pointer}
  button.secondary{background:#e6eefc;color:var(--accent)}
  .cols{display:grid;grid-template-columns:1fr 420px;gap:16px;margin-top:16px}
  .panel{background:#fff;padding:12px;border-radius:8px;min-height:220px;overflow:auto}
  .form-row{display:flex;align-items:center;gap:8px;margin-bottom:8px}
  label{width:160px;font-size:13px;color:var(--muted)}
  input[type=text], textarea, select{flex:1;padding:8px;border-radius:6px;border:1px solid #e2e8f0}
  textarea{height:60px;resize:vertical}
  .actions{display:flex;gap:8px;align-items:center;margin-top:10px}
  .meta{font-size:13px;color:var(--muted);margin-top:8px}
  .warning{background:#fff3cd;border:1px solid #ffeeba;color:#856404;padding:8px;border-radius:6px;font-size:13px}
  .small{font-size:13px;color:var(--muted)}
  .field-count{font-weight:600}
  footer{margin-top:18px;text-align:center;color:var(--muted);font-size:13px}
  @media(max-width:920px){.cols{grid-template-columns:1fr}}
  .modal{position:fixed;z-index:1000;left:0;top:0;width:100%;height:100%;overflow:auto;background-color:rgba(0,0,0,0.5);display:none;align-items:center;justify-content:center}
  .modal-content{background-color:#fff;padding:20px;border-radius:10px;box-shadow:0 5px 15px rgba(0,0,0,0.3);width:90%;max-width:600px;position:relative}
  .modal-close{color:#aaa;position:absolute;top:10px;right:15px;font-size:28px;font-weight:bold;cursor:pointer}
  .modal-close:hover,.modal-close:focus{color:#000;text-decoration:none}
  #modalContractData .data-row{display:flex;gap:8px;padding:4px 0;border-bottom:1px solid #eee}
  #modalContractData .data-key{font-weight:600;width:180px;color:#333;font-size:13px}
  #modalContractData .data-value{flex:1;color:#666;font-size:13px;word-break:break-word}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="card-header" style="display: flex; align-items: center; gap: 12px;">
      <img src="https://images.squarespace-cdn.com/content/v1/5f2bcafcac058b492651108a/7ac4fb80-c213-4ba0-a1a3-1d5e7b7c6ff8/Groupe-Ingena-Drims_logo.png?format=1500w" alt="Logo" style="height: 40px;"/>
      <h1>Remplisseur de formulaires DOCX — MVP</h1>
    </div>
    <p class="lead">Chargez un modèle Word (.docx) contenant des jetons comme <code>«nom_societe_client»</code>, remplissez les valeurs et générez un nouveau .docx avec uniquement les champs non vides remplacés.</p>

    <div class="row">
      <div>
        <label class="small">1) Choisissez un modèle Word (.docx)</label><br/>
        <input id="docxFile" type="file" accept=".docx"/>
      </div>
      <div style="min-width:240px">
        <label class="small">2) Champs détectés</label><br/>
        <div id="fieldCounter" class="small">Aucun fichier chargé</div>
      </div>
      <div style="margin-left:auto">
        <button id="generateBtn" disabled>Générer le Word</button>
      </div>
    </div>

    <div class="cols">
      <div>
        <div class="panel" id="formPanel">
          <div id="formIntro">
            <p class="small">Lorsque vous chargez un modèle, les champs détectés apparaîtront ici sous forme de champs de formulaire. Les champs sont détectés par le motif <code>«nom_du_champ_ici»</code> — les tirets bas seront convertis en espaces pour les étiquettes.</p>
            <div class="warning" id="warnSplit" style="display:none;margin-top:10px">
              Certains jetons de votre document peuvent être divisés entre plusieurs "runs" Word ; si la détection échoue pour certains jetons, essayez de vous assurer que le jeton est un seul "run" dans Word (modifiez et réappliquez la police sans style supplémentaire).
            </div>
          </div>
          <div id="formArea"></div>
        </div>
      </div>

      <div>
        <div class="panel">
          <h3 style="margin-top:0">Actions</h3>
          <div class="meta">
            <div><strong>Modèle chargé :</strong> <span id="tmplName">—</span></div>
            <div><strong>Champs détectés :</strong> <span id="tmplCount">0</span></div>
          </div>

          <div style="margin-top:12px">
            <button id="saveJson" class="secondary" disabled>Enregistrer les valeurs (.json)</button>
            <button id="loadJson" class="secondary" style="margin-left:6px">Charger les valeurs (.json)</button>
          </div>

          <div style="margin-top:10px">
            <label class="small">Aperçu des remplacements (non vides uniquement):</label>
            <div id="previewList" style="margin-top:6px;color:var(--muted)"></div>
          </div>

          <div class="actions" style="margin-top:12px">
            <button id="clearBtn" class="secondary">Effacer</button>
            <button id="helpBtn" class="secondary">Aide</button>
          </div>

          <div style="margin-top:12px">
            <div class="small">Comment ça marche : l'application lit le `.docx` (ZIP) dans le navigateur, extrait <code>word/document.xml</code>, normalise les "runs" de texte, trouve les jetons correspondant à <code>«...»</code>, construit le formulaire, et lors de la génération, remplace uniquement les jetons avec des valeurs non vides et télécharge un nouveau .docx.</div>
          </div>
        </div>
      </div>
    </div>

    <div style="margin-top: 16px;">
      <h3 style="margin-top:0">Contrats</h3>
      <div class="row" style="align-items: flex-end; gap: 8px;">
        <div style="flex: 1;">
          <label for="contractName" class="small">Nom du contrat</label><br/>
          <input type="text" id="contractName" placeholder="Ex: Contrat Client A" style="width: 98%;">
        </div>
        <button id="saveContractBtn" class="secondary">Enregistrer le contrat</button>
      </div>
      <div id="contractsList" class="panel" style="margin-top: 12px; min-height: 100px;">
        <div class="small">Les contrats enregistrés apparaîtront ici.</div>
      </div>
      <div style="margin-top: 12px;">
        <button id="generateSelectedBtn" disabled>Générer la sélection (.zip)</button>
        <button id="exportExcelBtn" class="secondary" style="margin-left: 6px;">Exporter vers Excel (.xlsx)</button>
      </div>
    </div>

    <footer>Créé pour vous — MVP monofichier hors ligne</footer>
  </div>
</div>

<div id="viewModal" class="modal">
  <div class="modal-content">
    <span class="modal-close">&times;</span>
    <h3 id="modalContractName" style="margin-top:0"></h3>
    <div id="modalContractData" class="panel" style="max-height: 400px; overflow-y: auto; background:#f9f9f9;"></div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

<script>
/*
  docx-form-mvp.html
  - Loads a .docx (client-side)
  - Finds tokens like «field_name»
  - Builds a form
  - Replaces non-empty values and downloads a new .docx

  Notes:
  - Some Word documents split text across <w:t> runs.
    We attempt a simple normalization step (merge adjacent runs) before scanning.
    This will often work for tokens that are not heavily formatted across runs.
*/

// --- IndexedDB Helper ---
const idbHelper = {
  db: null,
  dbName: 'docxContractsDB',
  storeName: 'contracts',

  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1);
      request.onerror = (event) => {
        console.error('IndexedDB error:', request.error);
        reject('Error opening IndexedDB.');
      };
      request.onsuccess = (event) => {
        this.db = event.target.result;
        resolve();
      };
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          // The object store will store contract objects. We use an auto-incrementing key.
          db.createObjectStore(this.storeName, { autoIncrement: true, keyPath: 'id' });
        }
      };
    });
  },

  async getContracts() {
    return new Promise((resolve, reject) => {
      if (!this.db) return reject('DB not initialized');
      const transaction = this.db.transaction([this.storeName], 'readonly');
      const store = transaction.objectStore(this.storeName);
      const request = store.getAll();
      request.onerror = (event) => reject('Error fetching contracts.');
      request.onsuccess = (event) => resolve(event.target.result);
    });
  },

  async saveContract(contract) {
    return new Promise((resolve, reject) => {
      if (!this.db) return reject('DB not initialized');
      const transaction = this.db.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      // Use put to handle both insert and update. It returns the key on success.
      const request = store.put(contract);
      request.onerror = (event) => reject('Error saving contract.');
      request.onsuccess = (event) => resolve(event.target.result);
    });
  },

  async deleteContract(contractId) {
    return new Promise((resolve, reject) => {
      if (!this.db) return reject('DB not initialized');
      const transaction = this.db.transaction([this.storeName], 'readwrite');
      const store = transaction.objectStore(this.storeName);
      const request = store.delete(contractId);
      request.onerror = (event) => reject('Error deleting contract.');
      request.onsuccess = (event) => resolve();
    });
  }
};
// --- End IndexedDB Helper ---


const fileInput = document.getElementById('docxFile');
const formArea = document.getElementById('formArea');
const fieldCounter = document.getElementById('fieldCounter');
const tmplName = document.getElementById('tmplName');
const tmplCount = document.getElementById('tmplCount');
const generateBtn = document.getElementById('generateBtn');
const saveJsonBtn = document.getElementById('saveJson');
const loadJsonBtn = document.getElementById('loadJson');
const previewList = document.getElementById('previewList');
const clearBtn = document.getElementById('clearBtn');
const helpBtn = document.getElementById('helpBtn');
const warnSplit = document.getElementById('warnSplit');
const viewModal = document.getElementById('viewModal');
const modalContractName = document.getElementById('modalContractName');
const modalContractData = document.getElementById('modalContractData');
const modalCloseBtn = document.querySelector('.modal-close');

let currentZip = null;
let originalDocumentXml = null;
let detectedFields = []; // array of field names
let templateFilename = null;

const contractNameInput = document.getElementById('contractName');
const saveContractBtn = document.getElementById('saveContractBtn');
const contractsList = document.getElementById('contractsList');
const generateSelectedBtn = document.getElementById('generateSelectedBtn');
const exportExcelBtn = document.getElementById('exportExcelBtn');

let savedContracts = [];

// --- Excel Export Logic ---
function exportToExcel() {
  if (savedContracts.length === 0) {
    alert('Aucun contrat à exporter.');
    return;
  }

  // Get all unique field names from all contracts to create the header row
  const allFields = new Set();
  savedContracts.forEach(contract => {
    Object.keys(contract.values).forEach(field => allFields.add(field));
  });
  const sortedFields = Array.from(allFields).sort();

  // Create the header row
  const header = ['Nom du Contrat', ...sortedFields];
  
  // Create the data rows
  const data = savedContracts.map(contract => {
    const row = [contract.name];
    sortedFields.forEach(field => {
      row.push(contract.values[field] || ''); // Add value or empty string if field not present
    });
    return row;
  });

  // Create worksheet and workbook
  const ws = XLSX.utils.aoa_to_sheet([header, ...data]);
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, 'Contrats');

  // Generate and download the file
  const excelFileName = templateFilename ? templateFilename.replace(/\.docx$/i, '') + '_export.xlsx' : 'contrats_export.xlsx';
  XLSX.writeFile(wb, excelFileName);
}

exportExcelBtn.addEventListener('click', exportToExcel);
// --- End Excel Export Logic ---


// --- Modal Logic ---
function showViewModal(contract) {
  modalContractName.textContent = contract.name;
  modalContractData.innerHTML = '';
  const frag = document.createDocumentFragment();
  const sortedValues = Object.entries(contract.values).sort(([keyA], [keyB]) => keyA.localeCompare(keyB));

  for (const [key, value] of sortedValues) {
    if (value) { // Only show non-empty values
      const row = document.createElement('div');
      row.className = 'data-row';
      const keyEl = document.createElement('div');
      keyEl.className = 'data-key';
      keyEl.textContent = prettyLabel(key);
      const valEl = document.createElement('div');
      valEl.className = 'data-value';
      valEl.textContent = value;
      row.appendChild(keyEl);
      row.appendChild(valEl);
      frag.appendChild(row);
    }
  }
  modalContractData.appendChild(frag);
  viewModal.style.display = 'flex';
}

function hideViewModal() {
  viewModal.style.display = 'none';
}

modalCloseBtn.addEventListener('click', hideViewModal);
window.addEventListener('click', (event) => {
  if (event.target == viewModal) {
    hideViewModal();
  }
});
// --- End Modal Logic ---

// Initializer function
async function initializeApp() {
  try {
    await idbHelper.init();
    savedContracts = await idbHelper.getContracts();
    renderContractsList();
  } catch (err) {
    console.error('Could not initialize IndexedDB:', err);
    alert('Avertissement : Impossible de charger les contrats enregistrés. Les données ne seront pas conservées.');
  }
}

// Call initializer on page load
document.addEventListener('DOMContentLoaded', initializeApp);


fileInput.addEventListener('change', async (e) => {
  const f = e.target.files && e.target.files[0];
  resetState();
  if (!f) return;
  if (!f.name.toLowerCase().endsWith('.docx')) {
    alert('Veuillez sélectionner un fichier .docx');
    return;
  }
  templateFilename = f.name;
  tmplName.textContent = f.name;
  fieldCounter.textContent = 'Lecture du fichier...';
  try {
    const arrayBuffer = await f.arrayBuffer();
    const zip = await JSZip.loadAsync(arrayBuffer);
    currentZip = zip;
    // Read document.xml
    const docXmlFile = zip.file('word/document.xml');
    if (!docXmlFile) {
      alert('Ce .docx ne contient pas word/document.xml (ce n\'est pas un document Word valide).');
      resetState();
      return;
    }

    const headerFooterFiles = [
      'word/header1.xml', 'word/header2.xml', 'word/header3.xml',
      'word/footer1.xml', 'word/footer2.xml', 'word/footer3.xml', 'word/document.xml'
    ];

    let xmlText = "";
    for (const fileName of headerFooterFiles) {
      const headerFooterFile = zip.file(fileName);
      if (headerFooterFile) {
        try {
          const content = await headerFooterFile.async('text');
          if (content) {
            xmlText += content + ' ';
          }
        } catch (e) {
          console.warn(`Could not read ${fileName}, which is fine.`, e);
        }
      }
    }

    
    // xmlText = await docXmlFile.async('text');

    // Also read headers and footers
    

    // Basic normalization: join adjacent <w:t> tags to reduce run-splits.
    // This is a pragmatic step for MVP; it may remove some formatting information
    // but helps detect tokens like «field_name» when Word split them across runs.
    const normalized = normalizeRuns(xmlText);
    originalDocumentXml = normalized;
    // detect tokens: «...»
    detectedFields = extractFields(normalized);
    // unique and keep order
    // detectedFields = Array.from(new Set(detectedFields));
    buildForm(detectedFields);
    fieldCounter.textContent = detectedFields.length ? `${detectedFields.length} champs détectés` : 'Aucun champ détecté';
    tmplCount.textContent = detectedFields.length;
    generateBtn.disabled = detectedFields.length === 0;
    saveJsonBtn.disabled = detectedFields.length === 0;
    contractNameInput.disabled = detectedFields.length === 0;
    saveContractBtn.disabled = detectedFields.length === 0;
    // After loading a template, re-evaluate the generate button state
    renderContractsList();
    warnSplit.style.display = ''; // show and hide based on detection issues
    if (detectedFields.length === 0) {
      warnSplit.style.display = 'block';
      warnSplit.innerText = 'Aucun jeton détecté. Cela peut être dû au fait que les jetons sont divisés entre plusieurs "runs" de texte Word d\'une manière que l\'application n\'a pas pu normaliser. Essayez de vous assurer que vos jetons sont en texte brut (un seul "run") dans Word, ou supprimez la mise en forme autour du jeton.';
    } else {
      warnSplit.style.display = 'none';
    }
  } catch (err) {
    console.error(err);
    alert('Erreur lors de la lecture du .docx: ' + (err && err.message ? err.message : err));
    resetState();
  }
});

function resetState() {
  currentZip = null;
  originalDocumentXml = null;
  detectedFields = [];
  templateFilename = null;
  formArea.innerHTML = '';
  fieldCounter.textContent = 'Aucun fichier chargé';
  tmplName.textContent = '—';
  tmplCount.textContent = '0';
  generateBtn.disabled = true;
  saveJsonBtn.disabled = true;
  previewList.innerHTML = '';
  warnSplit.style.display = 'none';
  if(contractNameInput) contractNameInput.disabled = true;
  if(saveContractBtn) saveContractBtn.disabled = true;
  if(generateSelectedBtn) generateSelectedBtn.disabled = true;
  // DO NOT clear savedContracts or re-render here, as they are persistent.
}

function normalizeRuns(xml) {
  // Merge adjacent text nodes: replace patterns like </w:t><w:t ...> with nothing between so tokens are contiguous.
  // Keep attributes of the first tag; remove the closing/opening boundary so the inner text is contiguous.
  // Note: this is a pragmatic transformation that may remove some formatting boundaries.
  // We'll do two passes: remove boundaries and also remove <w:tab/> which can split tokens
  let out = xml;

  // Remove w:tab tags that could split tokens
  out = out.replace(/<w:tab\/>/g, '');

  // Merge sequences of '</w:t></w:r><w:r[^>]*><w:t[^>]*>' into '' boundary
  // We'll replace the pattern multiple times until stable
  const pattern = /<\/w:t>\s*<\/w:r>\s*<w:r[^>]*>\s*<w:t[^>]*>/gi;
  let prev;
  do {
    prev = out;
    out = out.replace(pattern, '');
  } while (out !== prev);

  // Additionally, some templates use <w:instrText> for fields, ensure we normalize them by removing boundaries similarly
  const pattern2 = /<\/w:t>\s*<w:br\/>\s*<w:t[^>]*>/gi;
  out = out.replace(pattern2, '');

  return out;
}

function removeAllXmlMarkup(documentXml){
  const textContentRegex = /<w:t(?:\s[^>]*)?>([^<]*)<\/w:t>/g;
  let textMatch;
  let fullText = '';
  while ((textMatch = textContentRegex.exec(documentXml)) !== null) {
    fullText += textMatch[1];
  }
  return fullText;
}

function diffArr(sourceArr, destArr){
  const setFromArray = new Set(sourceArr);
  const setFromString = new Set(destArr);

  // Filter myArray to include only items NOT found in the stringArray Set
  const differenceA = sourceArr.filter(item => !setFromString.has(item));

  console.log(differenceA);
}

function extractFields(xml) {
  fullText = removeAllXmlMarkup(xml);

  const regex = /«([^»]+)»/g;
  let match;
  const foundTags = new Set();
  while ((match = regex.exec(fullText)) !== null) {
    const fieldName = match[1].trim();
    // Validate: field name should only contain lowercase letters, numbers, and underscores
    // and MUST contain at least one underscore to be considered a valid merge field
    if (fieldName && /^[a-z0-9_]+$/.test(fieldName) && fieldName.includes('_')) {
      foundTags.add(fieldName);
    } else {
      console.warn('Ignoring invalid field name:', fieldName);
    }
  }
  const foundTagsArr = Array.from(foundTags);

  const delimitedString = "num_contrat;nom_societe_client;nom_societe_client2;nom_societe_client3;nom_societe_client4;adresse_societe_client;siren_client;num_orias;nom_representant;fonction_representant;groupe_client;num_reference;date_appel_offre;date_cahier_charges_client;nb_jour_test_client;debut_date_test;fin_date_test;nom_editeur;nom_solution;date_effet_contrat;duree_annee_contrat;nom_prenom_prestataire;adresse_prestataire;email_prestataire;tel_prestataire;nom_prenom_client;adresse_client;email_client;tel_client;email_compta_client;nom_departement_facture_client;delai_reponse_client;delai_reponse_prestataire;nom_direction_client;fonction_direction_client;nom_solution_gestion_risque;nom_solution_gestion_risque2;nom_editeur_risque;nom_editeur_risque;nom_editeur_risque_long;date_mise_en_prod;tel_editeur_risque;mail_editeur_risque";

  const stringArray = delimitedString.split(';');
  console.log("Array foundTags Size:", foundTagsArr.length);
  console.log("Array Excel tag Size:", stringArray.length);

  console.log("items not in excel")
  diffArr(foundTagsArr, stringArray);

  console.log("in excel, but not in word")
  diffArr(stringArray, foundTagsArr);

  return foundTagsArr;

}

function buildForm(fields) {
  formArea.innerHTML = '';
  if (!fields || fields.length === 0) {
    formArea.innerHTML = '<div class="small">Aucun champ détecté. Chargez un modèle avec des jetons comme «nom_du_champ».</div>';
    return;
  }
  const frag = document.createDocumentFragment();
  fields.forEach(name => {
    const row = document.createElement('div');
    row.className = 'form-row';
    const label = document.createElement('label');
    label.textContent = prettyLabel(name);
    label.htmlFor = 'f_' + name;
    const input = document.createElement('input');
    input.type = 'text';
    input.id = 'f_' + name;
    input.dataset.fieldName = name;
    input.placeholder = name;
    input.addEventListener('input', updatePreview);
    row.appendChild(label);
    row.appendChild(input);
    frag.appendChild(row);
  });
  formArea.appendChild(frag);
  updatePreview();
}

function prettyLabel(name) {
  return (name || '').replace(/_/g, ' ').replace(/\b\w/g, s => s.toUpperCase());
}

function gatherValues() {
  const inputs = formArea.querySelectorAll('input[data-field-name], textarea[data-field-name], select[data-field-name]');
  const values = {};
  inputs.forEach(inp => {
    const k = inp.dataset.fieldName;
    const v = (inp.value || '').toString();
    values[k] = v;
  });
  return values;
}

function updatePreview() {
  const vals = gatherValues();
  const entries = Object.entries(vals).filter(([k,v]) => v && v.trim() !== '');
  if (entries.length === 0) {
    previewList.innerHTML = '<div class="small">Aucun remplacement sélectionné (tous les champs sont vides).</div>';
    return;
  }
  previewList.innerHTML = '';
  entries.slice(0,100).forEach(([k,v]) => {
    const d = document.createElement('div');
    d.textContent = `${prettyLabel(k)} → ${v}`;
    previewList.appendChild(d);
  });
  if (entries.length > 100) {
    const more = document.createElement('div');
    more.className = 'small';
    more.textContent = `...et ${entries.length - 100} de plus`;
    previewList.appendChild(more);
  }
}

generateBtn.addEventListener('click', async () => {
  if (!currentZip || !originalDocumentXml) { alert('Aucun modèle chargé'); return; }
  const values = gatherValues();
  // perform replacements for non-empty values only
  let modifiedXml = originalDocumentXml;
  Object.entries(values).forEach(([key, val]) => {
    if (val === null || val === undefined) return;
    const trimmed = val.toString().trim();
    if (trimmed.length === 0) return; // skip empty -> leave token as-is
    // Escape &,<,>
    const esc = escapeXml(trimmed);
    // Replace all occurrences of «key» with escaped text.
    // Use global replace with regex, but escape key for regex.
    const token = `«${key}»`;
    // Use split/join to avoid regex escaping complexity
    modifiedXml = modifiedXml.split(token).join(esc);
  });

  // Put modifiedXml back into zip and generate new docx
  try {
    const newZip = new JSZip();
    // copy all files from currentZip to newZip, but replace document.xml
    const files = Object.keys(currentZip.files);
    // We'll use async loops
    for (const path of files) {
      if (path === 'word/document.xml') {
        newZip.file(path, modifiedXml);
      } else {
        const f = currentZip.file(path);
        if (!f) continue;
        const content = await f.async('uint8array');
        newZip.file(path, content);
      }
    }
    const outBlob = await newZip.generateAsync({type:'blob'});
    const outName = templateFilename ? templateFilename.replace(/\.docx$/i,'') + '_filled.docx' : 'generated.docx';
    downloadBlob(outBlob, outName);
  } catch (err) {
    console.error(err);
    alert('Erreur lors de la génération du nouveau .docx: ' + (err && err.message ? err.message : err));
  }
});

function downloadBlob(blob, filename) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 5000);
}

function escapeXml(unsafe) {
  return unsafe.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

// Save form values as JSON file
saveJsonBtn.addEventListener('click', () => {
  const values = gatherValues();
  const blob = new Blob([JSON.stringify(values, null, 2)], {type:'application/json'});
  downloadBlob(blob, (templateFilename||'form') + '_values.json');
});

// Load form values from a JSON file
loadJsonBtn.addEventListener('click', () => {
  const inp = document.createElement('input');
  inp.type = 'file';
  inp.accept = '.json,application/json';
  inp.addEventListener('change', async (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    try {
      const text = await f.text();
      const obj = JSON.parse(text);
      // populate form fields that exist
      Object.entries(obj).forEach(([k,v]) => {
        const el = document.querySelector('[data-field-name="'+k+'"]');
        if (el) el.value = v;
      });
      updatePreview();
    } catch (err) {
      alert('Échec du chargement du JSON: ' + err);
    }
  });
  inp.click();
});

clearBtn.addEventListener('click', () => {
  const inputs = formArea.querySelectorAll('input[data-field-name], textarea[data-field-name], select[data-field-name]');
  inputs.forEach(i => i.value = '');
  updatePreview();
});

function renderContractsList() {
  contractsList.innerHTML = '';
  if (savedContracts.length === 0) {
    contractsList.innerHTML = '<div class="small">Les contrats enregistrés apparaîtront ici.</div>';
    generateSelectedBtn.disabled = true;
    return;
  }

  const frag = document.createDocumentFragment();
  savedContracts.forEach((contract, index) => {
    const contractRow = document.createElement('div');
    contractRow.className = 'form-row';
    contractRow.style.marginBottom = '4px';

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = `contract_chk_${contract.id}`;
    checkbox.dataset.contractId = contract.id;
    checkbox.style.width = 'auto';
    checkbox.addEventListener('change', () => {
        const anyChecked = Array.from(contractsList.querySelectorAll('input[type=checkbox]')).some(chk => chk.checked);
        generateSelectedBtn.disabled = !anyChecked || !currentZip;
    });


    const label = document.createElement('label');
    label.htmlFor = `contract_chk_${contract.id}`;
    label.textContent = contract.name;
    label.style.width = 'auto';
    label.style.flex = '1';

    const viewBtn = document.createElement('button');
    viewBtn.textContent = 'Voir';
    viewBtn.className = 'secondary';
    viewBtn.style.fontSize = '12px';
    viewBtn.style.padding = '4px 8px';
    viewBtn.addEventListener('click', () => {
      showViewModal(contract);
    });

    const loadBtn = document.createElement('button');
    loadBtn.textContent = 'Charger';
    loadBtn.className = 'secondary';
    loadBtn.style.fontSize = '12px';
    loadBtn.style.padding = '4px 8px';
    loadBtn.addEventListener('click', () => {
      // populate form
      Object.entries(contract.values).forEach(([k,v]) => {
        const el = document.querySelector('[data-field-name="'+k+'"]');
        if (el) el.value = v;
      });
      contractNameInput.value = contract.name;
      updatePreview();
    });

    const deleteBtn = document.createElement('button');
    deleteBtn.textContent = 'Supprimer';
    deleteBtn.className = 'secondary';
    deleteBtn.style.fontSize = '12px';
    deleteBtn.style.padding = '4px 8px';
    deleteBtn.addEventListener('click', () => {
      if (confirm(`Êtes-vous sûr de vouloir supprimer le contrat "${contract.name}" ?`)) {
        idbHelper.deleteContract(contract.id).catch(err => alert('Erreur lors de la suppression du contrat de la base de données.'));
        savedContracts = savedContracts.filter(c => c.id !== contract.id);
        renderContractsList();
      }
    });

    contractRow.appendChild(checkbox);
    contractRow.appendChild(label);
    contractRow.appendChild(viewBtn);
    contractRow.appendChild(loadBtn);
    contractRow.appendChild(deleteBtn);
    frag.appendChild(contractRow);
  });
  contractsList.appendChild(frag);
  const anyChecked = Array.from(contractsList.querySelectorAll('input[type=checkbox]')).some(chk => chk.checked);
  generateSelectedBtn.disabled = !anyChecked || !currentZip;
}

saveContractBtn.addEventListener('click', async () => {
  const values = gatherValues();
  const name = contractNameInput.value.trim();

  if (Object.values(values).every(v => v === '')) {
      alert('Le formulaire est vide, rien à enregistrer.');
      return;
  }

  if (!name) {
    alert('Veuillez donner un nom au contrat.');
    contractNameInput.focus();
    return;
  }

  const existingContract = savedContracts.find(c => c.name === name);
  if (existingContract) {
      if (confirm('Un contrat avec ce nom existe déjà. Voulez-vous le mettre à jour ?')) {
          existingContract.values = values;
          try {
            await idbHelper.saveContract(existingContract);
          } catch (err) {
            alert('Erreur lors de la mise à jour du contrat dans la base de données.');
          }
      } else {
          return;
      }
  } else {
      // For a new contract, omit the ID. IndexedDB will generate it.
      const newContract = {
        name: name,
        values: values
      };
      
      try {
        // The save returns the new ID, which we must assign to our in-memory object.
        const newId = await idbHelper.saveContract(newContract);
        newContract.id = newId; // Assign the DB-generated key
        savedContracts.push(newContract);
      } catch (err) {
        alert('Erreur lors de l\'enregistrement du contrat dans la base de données.');
      }
  }
  
  renderContractsList();
  contractNameInput.value = '';
});

generateSelectedBtn.addEventListener('click', async () => {
    if (!currentZip || !originalDocumentXml) { alert('Aucun modèle chargé'); return; }

    const selectedContracts = savedContracts.filter(c => {
        const chk = document.getElementById(`contract_chk_${c.id}`);
        return chk && chk.checked;
    });

    if (selectedContracts.length === 0) {
        alert('Veuillez sélectionner au moins un contrat à générer.');
        return;
    }

    const generationZip = new JSZip();
    let hasFailures = false;

    for (const contract of selectedContracts) {
        try {
            let modifiedXml = originalDocumentXml;
            Object.entries(contract.values).forEach(([key, val]) => {
                if (val === null || val === undefined) return;
                const trimmed = val.toString().trim();
                if (trimmed.length === 0) return;
                const esc = escapeXml(trimmed);
                const token = `«${key}»`;
                modifiedXml = modifiedXml.split(token).join(esc);
            });

            const newDocZip = new JSZip();
            for (const path of Object.keys(currentZip.files)) {
                if (path === 'word/document.xml') {
                    newDocZip.file(path, modifiedXml);
                } else {
                    const f = currentZip.file(path);
                    if (!f) continue;
                    const content = await f.async('uint8array');
                    newDocZip.file(path, content);
                }
            }
            const outBlob = await newDocZip.generateAsync({type:'blob'});
            const safeFilename = contract.name.replace(/[^a-z0-9_-\s]/gi, '_') + '.docx';
            generationZip.file(safeFilename, outBlob);

        } catch (err) {
            console.error(`Erreur lors de la génération du contrat "${contract.name}":`, err);
            hasFailures = true;
        }
    }

    if (hasFailures) {
        alert('Certains contrats n\'ont pas pu être générés. Vérifiez la console pour les erreurs.');
    }

    if (Object.keys(generationZip.files).length > 0) {
        const zipBlob = await generationZip.generateAsync({type:'blob'});
        const zipName = templateFilename ? templateFilename.replace(/\.docx$/i,'') + '_contrats.zip' : 'contrats.zip';
        downloadBlob(zipBlob, zipName);
    }
});

generateBtn.style.display = 'none';

helpBtn.addEventListener('click', () => {
  alert(`Aide MVP :
1) Dans votre modèle Word, placez des jetons comme «nom_du_champ_ici» (utilisez le tiret bas pour les espaces).
2) Enregistrez le .docx.
3) Chargez le .docx avec le bouton "Choisir un modèle Word".
4) Remplissez les valeurs dans le formulaire et cliquez sur "Générer le Word".
Remarques :
- Les valeurs vides laissent le jeton inchangé.
- Si les jetons ne sont pas détectés, ils peuvent être divisés entre plusieurs "runs" de texte Word ; essayez de retaper le jeton dans Word en texte brut (sans mise en forme spéciale).`);
});

</script>
</body>
</html>
